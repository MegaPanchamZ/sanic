#version 460

// Temporal Accumulation for SSR Reflections
// Reprojects previous frame's reflections using motion vectors and blends with current

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(push_constant) uniform PushConstants {
    int width;
    int height;
    float blendFactor;      // How much history to keep (0.9 = 90% history)
    float velocityScale;    // Scale factor for motion vectors
} pc;

layout(set = 0, binding = 0) uniform sampler2D currentReflection;
layout(set = 0, binding = 1) uniform sampler2D historyReflection;
layout(set = 0, binding = 2) uniform sampler2D velocityBuffer;  // Motion vectors (RG = velocity XY)
layout(set = 0, binding = 3) uniform sampler2D gDepth;
layout(set = 0, binding = 4, rgba16f) uniform writeonly image2D outputReflection;

// Color clamping for anti-ghosting
vec3 clipAABB(vec3 color, vec3 minColor, vec3 maxColor) {
    vec3 center = 0.5 * (maxColor + minColor);
    vec3 extents = 0.5 * (maxColor - minColor);
    
    vec3 offset = color - center;
    vec3 absOffset = abs(offset);
    vec3 ratio = absOffset / max(extents, vec3(0.0001));
    float maxRatio = max(max(ratio.x, ratio.y), ratio.z);
    
    if (maxRatio > 1.0) {
        return center + offset / maxRatio;
    }
    return color;
}

// Sample neighborhood to compute color bounds
void computeColorBounds(vec2 uv, vec2 texelSize, out vec3 minColor, out vec3 maxColor) {
    minColor = vec3(1e10);
    maxColor = vec3(-1e10);
    
    // 3x3 neighborhood
    for (int y = -1; y <= 1; y++) {
        for (int x = -1; x <= 1; x++) {
            vec2 sampleUV = uv + vec2(x, y) * texelSize;
            vec3 color = texture(currentReflection, sampleUV).rgb;
            minColor = min(minColor, color);
            maxColor = max(maxColor, color);
        }
    }
    
    // Expand bounds slightly to reduce flickering
    vec3 expand = (maxColor - minColor) * 0.1;
    minColor -= expand;
    maxColor += expand;
}

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    
    if (pixelCoord.x >= pc.width || pixelCoord.y >= pc.height) {
        return;
    }
    
    vec2 uv = (vec2(pixelCoord) + 0.5) / vec2(pc.width, pc.height);
    vec2 texelSize = 1.0 / vec2(pc.width, pc.height);
    
    // Sample current frame reflection
    vec4 currentColor = texture(currentReflection, uv);
    
    // Sample motion vectors (velocity in screen space, -1 to 1 or pixels)
    vec2 velocity = texture(velocityBuffer, uv).rg * pc.velocityScale;
    
    // Reproject to find corresponding pixel in previous frame
    vec2 historyUV = uv - velocity;
    
    // Check if history UV is valid
    if (historyUV.x < 0.0 || historyUV.x > 1.0 || 
        historyUV.y < 0.0 || historyUV.y > 1.0) {
        // No valid history, use current frame only
        imageStore(outputReflection, pixelCoord, currentColor);
        return;
    }
    
    // Sample history
    vec4 historyColor = texture(historyReflection, historyUV);
    
    // Compute color bounds from current frame neighborhood
    vec3 minColor, maxColor;
    computeColorBounds(uv, texelSize, minColor, maxColor);
    
    // Clip history color to current neighborhood bounds (anti-ghosting)
    vec3 clippedHistory = clipAABB(historyColor.rgb, minColor, maxColor);
    
    // Velocity-based confidence
    // Fast-moving pixels should use less history to reduce ghosting
    float velocityMag = length(velocity);
    float velocityConfidence = 1.0 / (1.0 + velocityMag * 100.0);
    
    // Adjust blend factor based on velocity
    float adaptiveBlend = mix(0.5, pc.blendFactor, velocityConfidence);
    
    // Blend current and history
    vec3 blendedColor = mix(currentColor.rgb, clippedHistory, adaptiveBlend);
    float blendedAlpha = mix(currentColor.a, historyColor.a, adaptiveBlend);
    
    // If current frame has valid data but history doesn't, favor current
    if (currentColor.a > 0.1 && historyColor.a < 0.1) {
        blendedColor = currentColor.rgb;
        blendedAlpha = currentColor.a;
    }
    
    imageStore(outputReflection, pixelCoord, vec4(blendedColor, blendedAlpha));
}
