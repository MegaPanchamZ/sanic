#version 460

// Edge-Preserving Spatial Denoiser for SSR Reflections
// Uses À-Trous wavelet filter with edge-stopping based on normal/depth

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(push_constant) uniform PushConstants {
    int passIndex;     // 0, 1, 2 for increasing filter sizes
    int width;
    int height;
    float sigmaLuminance;
    float sigmaNormal;
    float sigmaDepth;
} pc;

layout(set = 0, binding = 0) uniform sampler2D inputReflection;
layout(set = 0, binding = 1) uniform sampler2D gNormal;
layout(set = 0, binding = 2) uniform sampler2D gDepth;
layout(set = 0, binding = 3, rgba16f) uniform writeonly image2D outputReflection;

// À-Trous wavelet kernel weights (5x5)
const float kernel[25] = float[](
    1.0/256.0,  4.0/256.0,  6.0/256.0,  4.0/256.0, 1.0/256.0,
    4.0/256.0, 16.0/256.0, 24.0/256.0, 16.0/256.0, 4.0/256.0,
    6.0/256.0, 24.0/256.0, 36.0/256.0, 24.0/256.0, 6.0/256.0,
    4.0/256.0, 16.0/256.0, 24.0/256.0, 16.0/256.0, 4.0/256.0,
    1.0/256.0,  4.0/256.0,  6.0/256.0,  4.0/256.0, 1.0/256.0
);

// Gaussian for edge-stopping function
float gaussian(float x, float sigma) {
    return exp(-(x * x) / (2.0 * sigma * sigma));
}

// Compute luminance
float luminance(vec3 color) {
    return dot(color, vec3(0.299, 0.587, 0.114));
}

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    
    if (pixelCoord.x >= pc.width || pixelCoord.y >= pc.height) {
        return;
    }
    
    vec2 uv = (vec2(pixelCoord) + 0.5) / vec2(pc.width, pc.height);
    vec2 texelSize = 1.0 / vec2(pc.width, pc.height);
    
    // Sample center pixel
    vec4 centerColor = texture(inputReflection, uv);
    vec3 centerNormal = texture(gNormal, uv).xyz * 2.0 - 1.0;
    float centerDepth = texture(gDepth, uv).r;
    float centerLum = luminance(centerColor.rgb);
    
    // Skip if no reflection data
    if (centerColor.a < 0.001) {
        imageStore(outputReflection, pixelCoord, centerColor);
        return;
    }
    
    // À-Trous step size increases with pass index (1, 2, 4, 8, ...)
    int stepSize = 1 << pc.passIndex;
    
    vec4 colorSum = vec4(0.0);
    float weightSum = 0.0;
    
    // 5x5 kernel with À-Trous spacing
    for (int ky = -2; ky <= 2; ky++) {
        for (int kx = -2; kx <= 2; kx++) {
            ivec2 offset = ivec2(kx, ky) * stepSize;
            vec2 sampleUV = uv + vec2(offset) * texelSize;
            
            // Bounds check
            if (sampleUV.x < 0.0 || sampleUV.x > 1.0 || sampleUV.y < 0.0 || sampleUV.y > 1.0) {
                continue;
            }
            
            vec4 sampleColor = texture(inputReflection, sampleUV);
            vec3 sampleNormal = texture(gNormal, sampleUV).xyz * 2.0 - 1.0;
            float sampleDepth = texture(gDepth, sampleUV).r;
            
            // Kernel weight
            int kernelIndex = (ky + 2) * 5 + (kx + 2);
            float kernelWeight = kernel[kernelIndex];
            
            // Edge-stopping weights
            
            // Normal weight - preserve edges at normal discontinuities
            float normalDot = max(0.0, dot(centerNormal, sampleNormal));
            float normalWeight = pow(normalDot, pc.sigmaNormal);
            
            // Depth weight - preserve edges at depth discontinuities
            float depthDiff = abs(centerDepth - sampleDepth);
            float depthWeight = gaussian(depthDiff, pc.sigmaDepth);
            
            // Luminance weight - preserve color edges
            float sampleLum = luminance(sampleColor.rgb);
            float lumDiff = abs(centerLum - sampleLum);
            float lumWeight = gaussian(lumDiff, pc.sigmaLuminance);
            
            // Combined weight
            float weight = kernelWeight * normalWeight * depthWeight * lumWeight * sampleColor.a;
            
            colorSum += sampleColor * weight;
            weightSum += weight;
        }
    }
    
    vec4 result;
    if (weightSum > 0.001) {
        result = colorSum / weightSum;
    } else {
        result = centerColor;
    }
    
    // Preserve alpha
    result.a = centerColor.a;
    
    imageStore(outputReflection, pixelCoord, result);
}
