/**
 * rt_shadow.rahit
 * 
 * Any-hit shader for shadow rays - handles alpha testing.
 * 
 * Turn 37-39: Ray-traced Shadows
 */

#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_buffer_reference : require

layout(location = 0) rayPayloadInEXT float shadowPayload;

hitAttributeEXT vec2 barycentricCoords;

// For alpha tested geometry
layout(set = 1, binding = 0) uniform sampler2D textures[];

struct Material {
    uint albedoTexture;
    uint normalTexture;
    uint roughnessTexture;
    uint metallicTexture;
    vec4 baseColor;
    float alphaCutoff;
    uint flags;
    vec2 pad;
};

layout(set = 1, binding = 1, scalar) readonly buffer Materials {
    Material materials[];
};

layout(buffer_reference, scalar) readonly buffer VertexBuffer {
    vec4 data[];  // Position, normal, UV packed
};

layout(set = 1, binding = 2, scalar) readonly buffer VertexBuffers {
    VertexBuffer buffers[];
};

layout(set = 1, binding = 3, scalar) readonly buffer IndexBuffer {
    uint indices[];
};

void main() {
    // Get material
    uint materialIdx = gl_InstanceCustomIndexEXT;
    Material mat = materials[materialIdx];
    
    // Check if alpha testing is enabled
    if ((mat.flags & 1u) == 0u) {
        // Opaque - report hit
        shadowPayload = 0.0;
        terminateRayEXT;
        return;
    }
    
    // For alpha-tested materials, sample texture
    // Get vertex data for UV interpolation
    uint primitiveId = gl_PrimitiveID;
    uint i0 = indices[primitiveId * 3 + 0];
    uint i1 = indices[primitiveId * 3 + 1];
    uint i2 = indices[primitiveId * 3 + 2];
    
    // This is simplified - real implementation would read UVs
    // and sample the alpha texture
    float alpha = mat.baseColor.a;
    
    if (alpha < mat.alphaCutoff) {
        // Transparent - ignore hit
        ignoreIntersectionEXT;
    } else {
        // Opaque - shadow
        shadowPayload = 0.0;
        terminateRayEXT;
    }
}
