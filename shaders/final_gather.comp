/**
 * final_gather.comp
 * 
 * Final gather pass combining all GI sources.
 * Integrates screen probes, radiance cache, and surface cache.
 * 
 * Turn 31-33: Final gathering
 */

#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : enable

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// GI sources
layout(set = 0, binding = 0) uniform sampler2D screenProbeGI;
layout(set = 0, binding = 1) uniform sampler2D radianceCacheGI;
layout(set = 0, binding = 2) uniform sampler2D surfaceCacheGI;
layout(set = 0, binding = 3) uniform sampler2D ssrReflections;
layout(set = 0, binding = 4) uniform sampler2D sdfAO;

// G-Buffer
layout(set = 0, binding = 5) uniform sampler2D depthBuffer;
layout(set = 0, binding = 6) uniform sampler2D normalBuffer;
layout(set = 0, binding = 7) uniform sampler2D albedoBuffer;
layout(set = 0, binding = 8) uniform sampler2D roughnessBuffer;

// Environment
layout(set = 0, binding = 9) uniform samplerCube skybox;

// Outputs
layout(rgba16f, set = 0, binding = 10) uniform image2D diffuseGI;
layout(rgba16f, set = 0, binding = 11) uniform image2D specularGI;
layout(r16f, set = 0, binding = 12) uniform image2D aoOutput;
layout(rgba16f, set = 0, binding = 13) uniform image2D bentNormals;

layout(push_constant) uniform PushConstants {
    mat4 invViewProj;
    vec4 cameraPos;
    vec4 screenSize;
    vec4 sunDirection;
    float skyIntensity;
    float giIntensity;
    float aoStrength;
    float roughnessThreshold;
    uint gatherSamples;
    float gatherRadius;
    float padding1;
    float padding2;
};

// Reconstruct world position
vec3 reconstructWorldPos(vec2 uv, float depth) {
    vec4 clipPos = vec4(uv * 2.0 - 1.0, depth, 1.0);
    vec4 worldPos = invViewProj * clipPos;
    return worldPos.xyz / worldPos.w;
}

// Fresnel-Schlick approximation
vec3 fresnelSchlick(float cosTheta, vec3 F0) {
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

// Sample environment with roughness-based mip
vec3 sampleEnvironment(vec3 direction, float roughness) {
    float mipLevel = roughness * 7.0;  // Assuming 8 mip levels
    return textureLod(skybox, direction, mipLevel).rgb * skyIntensity;
}

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    
    if (pixelCoord.x >= int(screenSize.x) || pixelCoord.y >= int(screenSize.y)) return;
    
    vec2 uv = (vec2(pixelCoord) + 0.5) * screenSize.zw;
    
    float depth = texture(depthBuffer, uv).r;
    
    // Sky pixel
    if (depth >= 1.0) {
        imageStore(diffuseGI, pixelCoord, vec4(0.0));
        imageStore(specularGI, pixelCoord, vec4(0.0));
        imageStore(aoOutput, pixelCoord, vec4(1.0));
        imageStore(bentNormals, pixelCoord, vec4(0.0, 1.0, 0.0, 1.0));
        return;
    }
    
    vec3 normal = texture(normalBuffer, uv).xyz * 2.0 - 1.0;
    vec3 albedo = texture(albedoBuffer, uv).rgb;
    float roughness = texture(roughnessBuffer, uv).r;
    vec3 worldPos = reconstructWorldPos(uv, depth);
    vec3 viewDir = normalize(cameraPos.xyz - worldPos);
    
    // === Diffuse GI ===
    
    // Sample screen probe contribution
    vec3 probeGI = texture(screenProbeGI, uv).rgb;
    
    // Sample radiance cache contribution
    vec3 cacheGI = texture(radianceCacheGI, uv).rgb;
    
    // Sample surface cache (for static geometry)
    vec3 surfaceGI = texture(surfaceCacheGI, uv).rgb;
    
    // Blend sources based on quality/availability
    // Screen probes are most accurate for dynamic content
    // Radiance cache provides stable baseline
    // Surface cache for high-quality static geometry
    
    vec3 totalDiffuseGI = probeGI * 0.5 + cacheGI * 0.3 + surfaceGI * 0.2;
    
    // === Specular GI ===
    
    // Reflection direction
    vec3 reflectDir = reflect(-viewDir, normal);
    
    // SSR contribution
    vec4 ssrData = texture(ssrReflections, uv);
    vec3 ssrColor = ssrData.rgb;
    float ssrConfidence = ssrData.a;
    
    // Environment fallback
    vec3 envReflection = sampleEnvironment(reflectDir, roughness);
    
    // Fresnel
    float NdotV = max(dot(normal, viewDir), 0.0);
    vec3 F0 = mix(vec3(0.04), albedo, 0.0);  // Assuming non-metallic for now
    vec3 F = fresnelSchlick(NdotV, F0);
    
    // Blend SSR with environment based on confidence
    vec3 totalSpecularGI = mix(envReflection, ssrColor, ssrConfidence);
    
    // Apply fresnel
    totalSpecularGI *= F;
    
    // Rough surfaces get more diffuse, less specular
    float specularWeight = 1.0 - roughness * roughness;
    totalSpecularGI *= specularWeight;
    
    // === Ambient Occlusion ===
    
    float sdfAOValue = texture(sdfAO, uv).r;
    
    // Compute local AO from probe depth variance
    float localAO = 1.0;
    
    // Combine AO sources
    float finalAO = sdfAOValue * localAO;
    finalAO = 1.0 - (1.0 - finalAO) * aoStrength;
    
    // Apply AO to diffuse GI
    totalDiffuseGI *= finalAO;
    
    // === Bent Normals ===
    
    // Approximate bent normal from AO gradient
    // Sample AO in cross pattern
    float aoL = texture(sdfAO, uv + vec2(-1.0, 0.0) * screenSize.zw).r;
    float aoR = texture(sdfAO, uv + vec2(1.0, 0.0) * screenSize.zw).r;
    float aoU = texture(sdfAO, uv + vec2(0.0, -1.0) * screenSize.zw).r;
    float aoD = texture(sdfAO, uv + vec2(0.0, 1.0) * screenSize.zw).r;
    
    vec3 bentNormal = normal;
    bentNormal.x += (aoR - aoL) * 0.5;
    bentNormal.y += (aoD - aoU) * 0.5;
    bentNormal = normalize(bentNormal);
    
    // Blend bent normal towards geometric normal based on AO
    bentNormal = normalize(mix(bentNormal, normal, finalAO));
    
    // === Output ===
    
    imageStore(diffuseGI, pixelCoord, vec4(totalDiffuseGI * giIntensity, 1.0));
    imageStore(specularGI, pixelCoord, vec4(totalSpecularGI * giIntensity, 1.0));
    imageStore(aoOutput, pixelCoord, vec4(finalAO));
    imageStore(bentNormals, pixelCoord, vec4(bentNormal * 0.5 + 0.5, 1.0));
}
