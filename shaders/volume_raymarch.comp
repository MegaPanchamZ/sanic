/**
 * volume_raymarch.comp
 * 
 * Ray marching compute shader for heterogeneous volume rendering.
 * Based on Unreal Engine 5's Heterogeneous Volumes implementation.
 * 
 * Features:
 * - Adaptive step size based on density gradient
 * - Multi-scattering approximation  
 * - Temporal reprojection for stability
 * - Blackbody emission for fire
 * - Multiple phase function support
 */

#version 450
#extension GL_EXT_scalar_block_layout : enable

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// ============================================================================
// CONSTANTS
// ============================================================================

const float PI = 3.14159265359;
const float INV_PI = 0.31830988618;
const float INV_4PI = 0.07957747155;

const uint PHASE_ISOTROPIC = 0;
const uint PHASE_HENYEY_GREENSTEIN = 1;
const uint PHASE_RAYLEIGH = 2;
const uint PHASE_MIE = 3;
const uint PHASE_SCHLICK = 4;

const uint FLAG_TEMPORAL = 1;
const uint FLAG_JITTER = 2;
const uint FLAG_SHADOWS = 4;

// ============================================================================
// STRUCTURES
// ============================================================================

struct HeterogeneousVolume {
    mat4 worldMatrix;
    mat4 invWorldMatrix;
    
    vec4 boundsMin;         // xyz = min, w = densityScale
    vec4 boundsMax;         // xyz = max, w = temperatureScale
    
    vec4 scatteringAbsorption; // rgb = scattering, a = absorption.r
    vec4 absorptionEmission;   // rg = absorption.gb, ba = emission.rg
    vec4 emissionPhase;        // r = emission.b, g = phaseG, b = phaseType, a = flags
    
    uvec4 resolutionBrickCount;
    uvec4 atlasParams;
};

layout(std140, set = 0, binding = 0) uniform VolumeUniforms {
    mat4 viewMatrix;
    mat4 projMatrix;
    mat4 invViewMatrix;
    mat4 invProjMatrix;
    mat4 viewProjMatrix;
    mat4 prevViewProjMatrix;
    
    vec4 cameraPosition;
    vec4 screenParams;
    
    vec4 sunDirectionIntensity;
    vec4 sunColor;
    
    uint volumeCount;
    uint maxSteps;
    float stepSize;
    float time;
    
    uint flags;
    float temporalBlend;
    float jitterScale;
    uint frameIndex;
} uniforms;

layout(scalar, set = 0, binding = 1) readonly buffer VolumeBuffer {
    HeterogeneousVolume volumes[];
};

layout(set = 0, binding = 2) uniform sampler3D volumeAtlas;
layout(set = 0, binding = 3, rgba16f) uniform image2D outputScattering;
layout(set = 0, binding = 4, rgba16f) uniform image2D outputTransmittance;
layout(set = 0, binding = 5) uniform sampler2D depthBuffer;
layout(set = 0, binding = 6) uniform sampler2D historyBuffer;

// ============================================================================
// PHASE FUNCTIONS
// ============================================================================

float phaseIsotropic() {
    return INV_4PI;
}

float phaseHenyeyGreenstein(float cosTheta, float g) {
    float g2 = g * g;
    float denom = 1.0 + g2 - 2.0 * g * cosTheta;
    return INV_4PI * (1.0 - g2) / (denom * sqrt(denom));
}

float phaseRayleigh(float cosTheta) {
    return (3.0 / (16.0 * PI)) * (1.0 + cosTheta * cosTheta);
}

float phaseMie(float cosTheta, float g) {
    // Cornette-Shanks approximation
    float g2 = g * g;
    float num = 3.0 * (1.0 - g2) * (1.0 + cosTheta * cosTheta);
    float denom = (2.0 * (2.0 + g2)) * pow(1.0 + g2 - 2.0 * g * cosTheta, 1.5);
    return num / (8.0 * PI * denom);
}

float phaseSchlick(float cosTheta, float k) {
    float denom = 1.0 + k * cosTheta;
    return INV_4PI * (1.0 - k * k) / (denom * denom);
}

float evaluatePhase(uint phaseType, float cosTheta, float g) {
    switch (phaseType) {
        case PHASE_ISOTROPIC:
            return phaseIsotropic();
        case PHASE_HENYEY_GREENSTEIN:
            return phaseHenyeyGreenstein(cosTheta, g);
        case PHASE_RAYLEIGH:
            return phaseRayleigh(cosTheta);
        case PHASE_MIE:
            return phaseMie(cosTheta, g);
        case PHASE_SCHLICK:
            return phaseSchlick(cosTheta, g);
        default:
            return INV_4PI;
    }
}

// ============================================================================
// BLACKBODY / EMISSION
// ============================================================================

vec3 blackbodyColor(float temperature) {
    // Approximate Planckian locus color
    temperature = clamp(temperature, 1000.0, 40000.0);
    float t = temperature / 100.0;
    
    vec3 color;
    
    if (t <= 66.0) {
        color.r = 1.0;
        color.g = (99.4708025861 * log(t) - 161.1195681661) / 255.0;
    } else {
        color.r = 329.698727446 * pow(t - 60.0, -0.1332047592) / 255.0;
        color.g = 288.1221695283 * pow(t - 60.0, -0.0755148492) / 255.0;
    }
    
    if (t >= 66.0) {
        color.b = 1.0;
    } else if (t <= 19.0) {
        color.b = 0.0;
    } else {
        color.b = (138.5177312231 * log(t - 10.0) - 305.0447927307) / 255.0;
    }
    
    return clamp(color, 0.0, 1.0);
}

float blackbodyIntensity(float temperature, float baseIntensity) {
    // Stefan-Boltzmann approximation
    float normalized = temperature / 6500.0;
    return baseIntensity * pow(normalized, 4.0);
}

// ============================================================================
// RAY-BOX INTERSECTION
// ============================================================================

bool rayBoxIntersect(vec3 ro, vec3 rd, vec3 boxMin, vec3 boxMax, 
                     out float tNear, out float tFar) {
    vec3 invRd = 1.0 / rd;
    vec3 t0 = (boxMin - ro) * invRd;
    vec3 t1 = (boxMax - ro) * invRd;
    
    vec3 tMin = min(t0, t1);
    vec3 tMax = max(t0, t1);
    
    tNear = max(max(tMin.x, tMin.y), tMin.z);
    tFar = min(min(tMax.x, tMax.y), tMax.z);
    
    return tNear <= tFar && tFar > 0.0;
}

// ============================================================================
// VOLUME SAMPLING
// ============================================================================

vec4 sampleVolume(uint volumeIdx, vec3 localPos) {
    HeterogeneousVolume vol = volumes[volumeIdx];
    
    // Convert to UV coordinates
    vec3 uvw = (localPos - vol.boundsMin.xyz) / (vol.boundsMax.xyz - vol.boundsMin.xyz);
    
    if (any(lessThan(uvw, vec3(0.0))) || any(greaterThan(uvw, vec3(1.0)))) {
        return vec4(0.0);
    }
    
    // Sample from atlas
    // TODO: Compute actual atlas coordinates from atlasParams
    float density = texture(volumeAtlas, uvw).r;
    density *= vol.boundsMin.w; // densityScale
    
    return vec4(density, 0.0, 0.0, 0.0); // density, temperature, emission...
}

// ============================================================================
// JITTER / NOISE
// ============================================================================

float blueNoise(ivec2 coord, uint frame) {
    // Simple blue noise approximation using interleaved gradient noise
    vec2 p = vec2(coord) + float(frame) * vec2(0.754877669, 0.569840296);
    return fract(52.9829189 * fract(dot(p, vec2(0.06711056, 0.00583715))));
}

// ============================================================================
// MAIN RAYMARCH
// ============================================================================

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    vec2 screenSize = uniforms.screenParams.xy;
    
    if (pixelCoord.x >= int(screenSize.x) || pixelCoord.y >= int(screenSize.y)) {
        return;
    }
    
    // Generate ray
    vec2 uv = (vec2(pixelCoord) + 0.5) / screenSize;
    vec2 ndc = uv * 2.0 - 1.0;
    
    vec4 clipPos = vec4(ndc, 0.0, 1.0);
    vec4 viewPos = uniforms.invProjMatrix * clipPos;
    viewPos.xyz /= viewPos.w;
    
    vec3 rayOrigin = uniforms.cameraPosition.xyz;
    vec3 rayDir = normalize((uniforms.invViewMatrix * vec4(viewPos.xyz, 0.0)).xyz);
    
    // Get scene depth
    float depth = texture(depthBuffer, uv).r;
    float maxDist = depth < 1.0 ? length(viewPos.xyz) * linearizeDepth(depth) : 10000.0;
    
    // Jitter for temporal stability
    float jitter = 0.0;
    if ((uniforms.flags & FLAG_JITTER) != 0) {
        jitter = blueNoise(pixelCoord, uniforms.frameIndex) * uniforms.jitterScale;
    }
    
    // Accumulated values
    vec3 scatteringAccum = vec3(0.0);
    vec3 transmittance = vec3(1.0);
    
    // Raymarch each volume
    for (uint volIdx = 0; volIdx < uniforms.volumeCount; volIdx++) {
        HeterogeneousVolume vol = volumes[volIdx];
        
        // Transform ray to volume local space
        vec3 localOrigin = (vol.invWorldMatrix * vec4(rayOrigin, 1.0)).xyz;
        vec3 localDir = normalize((vol.invWorldMatrix * vec4(rayDir, 0.0)).xyz);
        
        // Intersect with volume bounds
        float tNear, tFar;
        if (!rayBoxIntersect(localOrigin, localDir, vol.boundsMin.xyz, vol.boundsMax.xyz, 
                            tNear, tFar)) {
            continue;
        }
        
        tNear = max(tNear, 0.0);
        tFar = min(tFar, maxDist);
        
        if (tNear >= tFar) continue;
        
        // Extract volume properties
        vec3 scattering = vol.scatteringAbsorption.rgb;
        vec3 absorption = vec3(vol.scatteringAbsorption.a, vol.absorptionEmission.rg);
        vec3 baseEmission = vec3(vol.absorptionEmission.ba, vol.emissionPhase.r);
        float phaseG = vol.emissionPhase.g;
        uint phaseType = uint(vol.emissionPhase.b);
        
        vec3 extinction = scattering + absorption;
        
        // Light direction for phase function
        vec3 sunDir = uniforms.sunDirectionIntensity.xyz;
        vec3 localSunDir = normalize((vol.invWorldMatrix * vec4(sunDir, 0.0)).xyz);
        float cosTheta = dot(-localDir, localSunDir);
        float phase = evaluatePhase(phaseType, cosTheta, phaseG);
        
        // Raymarch through volume
        float t = tNear + jitter * uniforms.stepSize;
        uint stepCount = 0;
        
        while (t < tFar && stepCount < uniforms.maxSteps) {
            vec3 samplePos = localOrigin + localDir * t;
            
            // Sample volume
            vec4 volumeSample = sampleVolume(volIdx, samplePos);
            float density = volumeSample.x;
            
            if (density > 0.001) {
                // Compute step transmittance
                float stepDist = uniforms.stepSize;
                vec3 stepExtinction = extinction * density * stepDist;
                vec3 stepTransmittance = exp(-stepExtinction);
                
                // In-scattering (single + multi-scattering approximation)
                vec3 sunLight = uniforms.sunColor.rgb * uniforms.sunDirectionIntensity.w;
                vec3 inScattering = scattering * density * sunLight * phase;
                
                // Emission
                vec3 emission = baseEmission * density;
                
                // Integrate
                vec3 luminance = inScattering + emission;
                vec3 integScatter = luminance * (1.0 - stepTransmittance) / max(stepExtinction, vec3(0.0001));
                
                scatteringAccum += transmittance * integScatter;
                transmittance *= stepTransmittance;
                
                // Early termination
                if (max(max(transmittance.r, transmittance.g), transmittance.b) < 0.01) {
                    break;
                }
            }
            
            t += uniforms.stepSize;
            stepCount++;
        }
    }
    
    // Temporal reprojection
    if ((uniforms.flags & FLAG_TEMPORAL) != 0) {
        // Reproject to previous frame
        vec4 clipPosPrev = uniforms.prevViewProjMatrix * vec4(rayOrigin + rayDir * 1.0, 1.0);
        vec2 uvPrev = clipPosPrev.xy / clipPosPrev.w * 0.5 + 0.5;
        
        if (uvPrev.x >= 0.0 && uvPrev.x <= 1.0 && uvPrev.y >= 0.0 && uvPrev.y <= 1.0) {
            vec4 history = texture(historyBuffer, uvPrev);
            scatteringAccum = mix(scatteringAccum, history.rgb, uniforms.temporalBlend);
        }
    }
    
    // Write results
    imageStore(outputScattering, pixelCoord, vec4(scatteringAccum, 1.0));
    imageStore(outputTransmittance, pixelCoord, vec4(transmittance, 1.0));
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

float linearizeDepth(float d) {
    // Reverse-Z depth linearization
    float n = 0.1;  // Near plane - should be from uniforms
    float f = 10000.0; // Far plane
    return n * f / (f - d * (f - n));
}
