/**
 * deferred_lighting.comp
 * 
 * Deferred lighting compute shader for final image composition.
 * Combines G-Buffer data with GI, shadows, and lighting.
 * 
 * Turn 40: Final Integration
 */

#version 460
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_scalar_block_layout : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// G-Buffer inputs
layout(set = 0, binding = 0) uniform sampler2D depthBuffer;
layout(set = 0, binding = 1) uniform usampler2D visBuffer;
layout(set = 0, binding = 2) uniform sampler2D normalBuffer;
layout(set = 0, binding = 3) uniform sampler2D albedoBuffer;
layout(set = 0, binding = 4) uniform sampler2D materialBuffer;
layout(set = 0, binding = 5) uniform sampler2D velocityBuffer;

// GI and shadow inputs
layout(set = 1, binding = 0) uniform sampler2D giBuffer;
layout(set = 1, binding = 1) uniform sampler2D shadowMask;
layout(set = 1, binding = 2) uniform sampler2D aoBuffer;
layout(set = 1, binding = 3) uniform sampler2D reflectionBuffer;
layout(set = 1, binding = 4) uniform sampler2D ssrBuffer;

// Output
layout(set = 2, binding = 0, rgba16f) writeonly uniform image2D hdrOutput;

// Frame uniforms
layout(set = 3, binding = 0, scalar) uniform FrameUniforms {
    mat4 viewMatrix;
    mat4 projMatrix;
    mat4 viewProjMatrix;
    mat4 invViewMatrix;
    mat4 invProjMatrix;
    mat4 invViewProjMatrix;
    mat4 prevViewProjMatrix;
    
    vec4 cameraPosition;
    vec4 cameraParams;
    vec4 screenSize;
    vec4 jitterOffset;
    
    vec4 sunDirection;
    vec4 sunColor;
    vec4 ambientColor;
    
    uint frameIndex;
    float deltaTime;
    float totalTime;
    uint flags;
    
    uint lightCount;
    uint clusterCount;
    uint materialCount;
    uint pad;
} frame;

// Light structure
struct Light {
    vec4 position;      // xyz = pos, w = type
    vec4 direction;     // xyz = dir, w = range
    vec4 color;         // xyz = color, w = intensity
    vec4 params;        // x = innerAngle, y = outerAngle, z = shadowIndex, w = enabled
};

layout(set = 3, binding = 1, scalar) readonly buffer LightBuffer {
    Light lights[];
};

// Constants
const float PI = 3.14159265359;
const float INV_PI = 0.31830988618;

// PBR functions
float distributionGGX(vec3 N, vec3 H, float roughness) {
    float a = roughness * roughness;
    float a2 = a * a;
    float NdotH = max(dot(N, H), 0.0);
    float NdotH2 = NdotH * NdotH;
    
    float nom = a2;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom = PI * denom * denom;
    
    return nom / max(denom, 0.0001);
}

float geometrySchlickGGX(float NdotV, float roughness) {
    float r = (roughness + 1.0);
    float k = (r * r) / 8.0;
    return NdotV / (NdotV * (1.0 - k) + k);
}

float geometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);
    float ggx2 = geometrySchlickGGX(NdotV, roughness);
    float ggx1 = geometrySchlickGGX(NdotL, roughness);
    return ggx1 * ggx2;
}

vec3 fresnelSchlick(float cosTheta, vec3 F0) {
    return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
}

vec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {
    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
}

// World position from depth
vec3 worldPositionFromDepth(vec2 uv, float depth) {
    vec4 clipPos = vec4(uv * 2.0 - 1.0, depth, 1.0);
    vec4 viewPos = frame.invProjMatrix * clipPos;
    viewPos /= viewPos.w;
    vec4 worldPos = frame.invViewMatrix * viewPos;
    return worldPos.xyz;
}

// Light attenuation
float calculateAttenuation(float distance, float range) {
    float attenuation = 1.0 / (distance * distance + 0.0001);
    float falloff = clamp(1.0 - pow(distance / range, 4.0), 0.0, 1.0);
    return attenuation * falloff * falloff;
}

// Spotlight falloff
float spotlightFalloff(vec3 L, vec3 spotDir, float innerAngle, float outerAngle) {
    float theta = dot(L, -spotDir);
    float epsilon = cos(innerAngle) - cos(outerAngle);
    return clamp((theta - cos(outerAngle)) / epsilon, 0.0, 1.0);
}

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    vec2 screenSize = frame.screenSize.xy;
    
    if (pixelCoord.x >= int(screenSize.x) || pixelCoord.y >= int(screenSize.y)) {
        return;
    }
    
    vec2 uv = (vec2(pixelCoord) + 0.5) / screenSize;
    
    // Sample G-Buffer
    float depth = texture(depthBuffer, uv).r;
    vec4 normalData = texture(normalBuffer, uv);
    vec4 albedoData = texture(albedoBuffer, uv);
    vec4 materialData = texture(materialBuffer, uv);
    
    // Early out for sky
    if (depth >= 1.0) {
        // Sky color - could sample skybox here
        vec3 skyColor = vec3(0.2, 0.3, 0.5);
        imageStore(hdrOutput, pixelCoord, vec4(skyColor, 1.0));
        return;
    }
    
    // Decode G-Buffer
    vec3 worldNormal = normalize(normalData.rgb * 2.0 - 1.0);
    vec3 albedo = albedoData.rgb;
    float metallic = materialData.r;
    float roughness = max(materialData.g, 0.04);
    float ao = materialData.b;
    float emissive = materialData.a;
    
    // Reconstruct world position
    vec3 worldPos = worldPositionFromDepth(uv, depth);
    vec3 viewDir = normalize(frame.cameraPosition.xyz - worldPos);
    
    // Calculate F0
    vec3 F0 = vec3(0.04);
    F0 = mix(F0, albedo, metallic);
    
    // Sample GI and shadows
    vec3 giContribution = texture(giBuffer, uv).rgb;
    float shadowValue = texture(shadowMask, uv).r;
    float aoValue = texture(aoBuffer, uv).r * ao;
    vec3 reflectionValue = texture(reflectionBuffer, uv).rgb;
    vec3 ssrValue = texture(ssrBuffer, uv).rgb;
    
    // Direct lighting
    vec3 Lo = vec3(0.0);
    
    // Sun light (directional)
    {
        vec3 L = normalize(-frame.sunDirection.xyz);
        vec3 H = normalize(viewDir + L);
        
        float NdotL = max(dot(worldNormal, L), 0.0);
        
        if (NdotL > 0.0) {
            float NDF = distributionGGX(worldNormal, H, roughness);
            float G = geometrySmith(worldNormal, viewDir, L, roughness);
            vec3 F = fresnelSchlick(max(dot(H, viewDir), 0.0), F0);
            
            vec3 kS = F;
            vec3 kD = (1.0 - kS) * (1.0 - metallic);
            
            vec3 numerator = NDF * G * F;
            float denominator = 4.0 * max(dot(worldNormal, viewDir), 0.0) * NdotL + 0.0001;
            vec3 specular = numerator / denominator;
            
            vec3 radiance = frame.sunColor.rgb * frame.sunDirection.w;
            Lo += (kD * albedo * INV_PI + specular) * radiance * NdotL * shadowValue;
        }
    }
    
    // Point and spot lights
    for (uint i = 0; i < frame.lightCount; i++) {
        Light light = lights[i];
        
        if (light.params.w < 0.5) continue; // Disabled
        
        vec3 lightPos = light.position.xyz;
        float lightType = light.position.w;
        float range = light.direction.w;
        
        vec3 L = lightPos - worldPos;
        float distance = length(L);
        L = normalize(L);
        
        if (distance > range) continue;
        
        float attenuation = calculateAttenuation(distance, range);
        
        // Spotlight falloff
        if (lightType > 1.5) { // Spot light
            attenuation *= spotlightFalloff(L, normalize(light.direction.xyz), 
                                            light.params.x, light.params.y);
        }
        
        if (attenuation < 0.001) continue;
        
        vec3 H = normalize(viewDir + L);
        float NdotL = max(dot(worldNormal, L), 0.0);
        
        if (NdotL > 0.0) {
            float NDF = distributionGGX(worldNormal, H, roughness);
            float G = geometrySmith(worldNormal, viewDir, L, roughness);
            vec3 F = fresnelSchlick(max(dot(H, viewDir), 0.0), F0);
            
            vec3 kS = F;
            vec3 kD = (1.0 - kS) * (1.0 - metallic);
            
            vec3 numerator = NDF * G * F;
            float denominator = 4.0 * max(dot(worldNormal, viewDir), 0.0) * NdotL + 0.0001;
            vec3 specular = numerator / denominator;
            
            vec3 radiance = light.color.rgb * light.color.w * attenuation;
            
            // Per-light shadow if available
            float lightShadow = 1.0;
            // TODO: Sample per-light shadow map using light.params.z
            
            Lo += (kD * albedo * INV_PI + specular) * radiance * NdotL * lightShadow;
        }
    }
    
    // Indirect lighting (GI)
    vec3 F = fresnelSchlickRoughness(max(dot(worldNormal, viewDir), 0.0), F0, roughness);
    vec3 kS = F;
    vec3 kD = (1.0 - kS) * (1.0 - metallic);
    
    vec3 diffuseGI = giContribution * albedo * kD;
    
    // Blend SSR with reflection probes
    float ssrMask = 1.0; // TODO: Use SSR confidence mask
    vec3 specularReflection = mix(reflectionValue, ssrValue, ssrMask) * F;
    
    vec3 ambient = (diffuseGI + specularReflection) * aoValue;
    
    // Combine lighting
    vec3 color = Lo + ambient;
    
    // Add emissive
    color += albedo * emissive * 10.0;
    
    // Store HDR result
    imageStore(hdrOutput, pixelCoord, vec4(color, 1.0));
}
