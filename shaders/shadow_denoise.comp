/**
 * shadow_denoise.comp
 * 
 * Spatio-temporal denoiser for ray-traced shadows.
 * Uses variance estimation and edge-aware filtering.
 * 
 * Turn 37-39: Ray-traced Shadows
 */

#version 460
#extension GL_EXT_scalar_block_layout : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform sampler2D rawShadow;      // Current frame raw shadow
layout(set = 0, binding = 1) uniform sampler2D historyBuffer;  // Previous frame filtered
layout(set = 0, binding = 2) uniform sampler2D depthBuffer;
layout(set = 0, binding = 3) uniform sampler2D normalBuffer;
layout(set = 0, binding = 4) uniform sampler2D motionVectors;  // Screen-space motion
layout(set = 0, binding = 5) uniform sampler2D prevDepthBuffer;

layout(set = 0, binding = 6, rg32f) writeonly uniform image2D momentsOutput;  // First and second moment
layout(set = 0, binding = 7, rgba8) writeonly uniform image2D denoisedOutput;

layout(push_constant) uniform PushConstants {
    mat4 invViewProj;
    mat4 prevViewProj;
    vec4 cameraPos;
    uint width;
    uint height;
    float temporalAlpha;       // Blend factor for temporal accumulation
    float spatialSigma;        // Spatial filter strength
    float varianceClamp;       // Variance clamping threshold
    uint spatialRadius;
    uint temporalEnabled;
    uint frameIndex;
} pc;

// Edge-stopping functions
float normalWeight(vec3 n1, vec3 n2) {
    return pow(max(0.0, dot(n1, n2)), 128.0);
}

float depthWeight(float z1, float z2, float gradient) {
    return exp(-abs(z1 - z2) / (gradient + 0.0001));
}

float luminanceWeight(float l1, float l2, float sigma) {
    return exp(-abs(l1 - l2) / (sigma + 0.0001));
}

// Compute local variance
vec2 computeLocalMoments(ivec2 coord) {
    float mean = 0.0;
    float meanSq = 0.0;
    float totalWeight = 0.0;
    
    for (int y = -1; y <= 1; y++) {
        for (int x = -1; x <= 1; x++) {
            ivec2 sampleCoord = coord + ivec2(x, y);
            float shadow = texelFetch(rawShadow, sampleCoord, 0).r;
            float weight = 1.0;
            
            mean += shadow * weight;
            meanSq += shadow * shadow * weight;
            totalWeight += weight;
        }
    }
    
    mean /= totalWeight;
    meanSq /= totalWeight;
    
    return vec2(mean, meanSq);
}

// Spatial denoising (edge-aware box filter)
float spatialFilter(ivec2 coord, vec3 centerNormal, float centerDepth) {
    float result = 0.0;
    float totalWeight = 0.0;
    
    float centerShadow = texelFetch(rawShadow, coord, 0).r;
    
    // Compute depth gradient
    float dxDepth = abs(texelFetch(depthBuffer, coord + ivec2(1, 0), 0).r - centerDepth);
    float dyDepth = abs(texelFetch(depthBuffer, coord + ivec2(0, 1), 0).r - centerDepth);
    float depthGradient = max(dxDepth, dyDepth);
    
    int radius = int(pc.spatialRadius);
    
    for (int y = -radius; y <= radius; y++) {
        for (int x = -radius; x <= radius; x++) {
            ivec2 sampleCoord = coord + ivec2(x, y);
            
            // Bounds check
            if (any(lessThan(sampleCoord, ivec2(0))) || 
                any(greaterThanEqual(sampleCoord, ivec2(pc.width, pc.height)))) {
                continue;
            }
            
            float sampleShadow = texelFetch(rawShadow, sampleCoord, 0).r;
            float sampleDepth = texelFetch(depthBuffer, sampleCoord, 0).r;
            vec3 sampleNormal = texelFetch(normalBuffer, sampleCoord, 0).xyz * 2.0 - 1.0;
            
            // Compute weights
            float nWeight = normalWeight(centerNormal, sampleNormal);
            float zWeight = depthWeight(centerDepth, sampleDepth, depthGradient);
            float lWeight = luminanceWeight(centerShadow, sampleShadow, pc.spatialSigma);
            
            // Gaussian spatial weight
            float dist = length(vec2(x, y));
            float gWeight = exp(-dist * dist / (2.0 * float(radius) * float(radius)));
            
            float weight = nWeight * zWeight * lWeight * gWeight;
            
            result += sampleShadow * weight;
            totalWeight += weight;
        }
    }
    
    return result / max(totalWeight, 0.0001);
}

// Temporal reprojection
float temporalReproject(ivec2 coord, float currentShadow, float variance) {
    vec2 uv = (vec2(coord) + 0.5) / vec2(pc.width, pc.height);
    
    // Get motion vector
    vec2 motion = texture(motionVectors, uv).xy;
    vec2 historyUV = uv - motion;
    
    // Check if history is valid
    if (any(lessThan(historyUV, vec2(0.0))) || any(greaterThan(historyUV, vec2(1.0)))) {
        return currentShadow;
    }
    
    // Sample history
    float historyShadow = texture(historyBuffer, historyUV).r;
    
    // Depth rejection
    float currentDepth = texelFetch(depthBuffer, coord, 0).r;
    float historyDepth = texture(prevDepthBuffer, historyUV).r;
    
    // Reconstruct world positions
    vec4 clipPos = vec4(uv * 2.0 - 1.0, currentDepth, 1.0);
    vec4 worldPos4 = pc.invViewProj * clipPos;
    vec3 worldPos = worldPos4.xyz / worldPos4.w;
    
    // Project to previous frame
    vec4 prevClip = pc.prevViewProj * vec4(worldPos, 1.0);
    prevClip.xyz /= prevClip.w;
    float expectedDepth = prevClip.z * 0.5 + 0.5;
    
    float depthDiff = abs(historyDepth - expectedDepth);
    if (depthDiff > 0.01) {
        return currentShadow;  // Disocclusion - reject history
    }
    
    // Variance-based clamping
    float stdDev = sqrt(max(0.0, variance));
    float clampedHistory = clamp(historyShadow, 
                                  currentShadow - stdDev * pc.varianceClamp,
                                  currentShadow + stdDev * pc.varianceClamp);
    
    // Blend
    float alpha = pc.temporalAlpha;
    return mix(clampedHistory, currentShadow, alpha);
}

void main() {
    ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
    if (gid.x >= int(pc.width) || gid.y >= int(pc.height)) return;
    
    float depth = texelFetch(depthBuffer, gid, 0).r;
    if (depth >= 1.0) {
        imageStore(denoisedOutput, gid, vec4(1.0));
        imageStore(momentsOutput, gid, vec2(1.0, 1.0));
        return;
    }
    
    vec3 normal = texelFetch(normalBuffer, gid, 0).xyz * 2.0 - 1.0;
    
    // Compute moments for variance estimation
    vec2 moments = computeLocalMoments(gid);
    float variance = max(0.0, moments.y - moments.x * moments.x);
    
    // Spatial filter
    float spatialFiltered = spatialFilter(gid, normal, depth);
    
    // Temporal filter
    float result = spatialFiltered;
    if (pc.temporalEnabled > 0) {
        result = temporalReproject(gid, spatialFiltered, variance);
    }
    
    imageStore(denoisedOutput, gid, vec4(result, result, result, 1.0));
    imageStore(momentsOutput, gid, vec2(result, result * result));
}
