#version 460
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_GOOGLE_include_directive : require

/*
 * Cluster Culling Compute Shader
 * ================================
 * GPU-driven culling for Nanite-style cluster hierarchy.
 * 
 * Performs:
 * 1. Frustum culling (AABB + sphere)
 * 2. LOD selection based on screen-space error
 * 3. Back-face cluster culling (cone test)
 * 4. Populates visible cluster list for mesh shader dispatch
 * 
 * Designed to run in persistent-threads style for hierarchical traversal.
 */

#include "cluster_common.glsl"

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Push constants for per-frame data
layout(push_constant) uniform PushConstants {
    mat4 viewProj;
    vec4 frustumPlanes[6];      // Frustum planes in world space
    vec4 cameraPosition;        // xyz = position, w = near plane
    vec4 screenParams;          // x = width, y = height, z = lodScale, w = errorThreshold
    uint clusterCount;
    uint nodeCount;
    uint frameIndex;
    uint flags;                 // bit 0 = enable frustum cull, bit 1 = enable occlusion cull
} pc;

// Buffer references for cluster data
layout(buffer_reference, std430, buffer_reference_align = 16) readonly buffer ClusterBufferRef {
    Cluster clusters[];
};

layout(buffer_reference, std430, buffer_reference_align = 16) readonly buffer HierarchyNodeBufferRef {
    HierarchyNode nodes[];
};

// Candidate and visible cluster queues (persistent threads style)
layout(set = 0, binding = 0, std430) buffer CandidateBuffer {
    CandidateNode candidateNodes[];
};

layout(set = 0, binding = 1, std430) buffer VisibleBuffer {
    VisibleCluster visibleClusters[];
};

layout(set = 0, binding = 2, std430) buffer QueueStateBuffer {
    QueueState queueState;
};

layout(set = 0, binding = 3) uniform BufferAddresses {
    uint64_t clusterBufferAddress;
    uint64_t hierarchyNodeBufferAddress;
} addresses;

// Shared memory for wave-level operations
shared uint sharedVisibleCount;
shared uint sharedVisibleBase;

/**
 * Frustum cull a cluster's bounding sphere
 */
bool frustumCullSphere(vec3 center, float radius) {
    for (int i = 0; i < 6; i++) {
        if (dot(pc.frustumPlanes[i].xyz, center) + pc.frustumPlanes[i].w < -radius) {
            return true; // Outside frustum
        }
    }
    return false;
}

/**
 * Frustum cull a cluster's AABB
 */
bool frustumCullAABB(vec3 boxCenter, vec3 boxExtent) {
    vec3 aabbMin = boxCenter - boxExtent;
    vec3 aabbMax = boxCenter + boxExtent;
    for (int i = 0; i < 6; i++) {
        vec3 p = mix(aabbMin, aabbMax, greaterThan(pc.frustumPlanes[i].xyz, vec3(0.0)));
        if (dot(pc.frustumPlanes[i].xyz, p) + pc.frustumPlanes[i].w < 0.0) {
            return true; // Outside frustum
        }
    }
    return false;
}

/**
 * Calculate projected error for LOD selection
 * Returns screen-space error in pixels
 */
float calculateProjectedError(vec3 center, float lodError) {
    float dist = max(distance(center, pc.cameraPosition.xyz), pc.cameraPosition.w);
    // Project world-space error to screen-space
    float screenHeight = pc.screenParams.y;
    float fovScale = pc.screenParams.z; // tan(fov/2) * 2
    float projectedError = (lodError * screenHeight) / (dist * fovScale);
    return projectedError;
}

/**
 * Check if a cluster should be drawn at this LOD
 * Uses the parent/child error thresholds to determine visibility
 */
bool shouldDrawCluster(ClusterBounds bounds) {
    float projectedError = calculateProjectedError(bounds.sphereCenter, bounds.lodError);
    float projectedParentError = calculateProjectedError(bounds.sphereCenter, bounds.parentLodError);
    float threshold = pc.screenParams.w;
    
    // Draw if:
    // - Our error is small enough (below threshold), AND
    // - Parent's error is too large (above threshold) OR we're at root (parentError == 0)
    bool errorSmallEnough = projectedError <= threshold;
    bool parentErrorTooLarge = projectedParentError > threshold || bounds.parentLodError <= 0.0;
    
    return errorSmallEnough && parentErrorTooLarge;
}

void main() {
    uint threadIndex = gl_GlobalInvocationID.x;
    
    // Initialize shared memory
    if (gl_LocalInvocationID.x == 0) {
        sharedVisibleCount = 0;
    }
    barrier();
    
    // Get buffer references
    ClusterBufferRef clusterBuf = ClusterBufferRef(addresses.clusterBufferAddress);
    HierarchyNodeBufferRef nodeBuf = HierarchyNodeBufferRef(addresses.hierarchyNodeBufferAddress);
    
    // Phase 1: Process clusters directly (flat culling)
    // In a full implementation, we'd do hierarchical traversal
    if (threadIndex < pc.clusterCount) {
        Cluster cluster = clusterBuf.clusters[threadIndex];
        
        bool visible = true;
        
        // Frustum culling
        if ((pc.flags & 1u) != 0) {
            // Quick sphere test first
            if (frustumCullSphere(cluster.bounds.sphereCenter, cluster.bounds.sphereRadius)) {
                visible = false;
            }
            // Tighter AABB test if sphere passed
            else {
                vec3 boxExtent = vec3(cluster.bounds.boxExtentX, cluster.bounds.boxExtentY, cluster.bounds.boxExtentZ);
                if (frustumCullAABB(cluster.bounds.boxCenter, boxExtent)) {
                    visible = false;
                }
            }
        }
        
        // LOD selection
        if (visible) {
            visible = shouldDrawCluster(cluster.bounds);
        }
        
        // Append to visible list
        if (visible) {
            uint localIndex = atomicAdd(sharedVisibleCount, 1);
            
            // First thread in wave allocates global indices
            barrier();
            if (gl_LocalInvocationID.x == 0 && sharedVisibleCount > 0) {
                sharedVisibleBase = atomicAdd(queueState.visibleClusterCount, sharedVisibleCount);
            }
            barrier();
            
            // Write visible cluster
            uint globalIndex = sharedVisibleBase + localIndex;
            if (globalIndex < queueState.maxVisibleClusters) {
                visibleClusters[globalIndex].clusterIndex = threadIndex;
                visibleClusters[globalIndex].instanceId = 0; // Single instance for now
                visibleClusters[globalIndex].flags = VISIBLE_FLAG_HW_RASTER; // Default to HW raster
                visibleClusters[globalIndex].pageIndex = 0;
            }
        }
    }
}
