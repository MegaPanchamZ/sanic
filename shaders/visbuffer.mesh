#version 460
#extension GL_EXT_mesh_shader : require
#extension GL_EXT_shader_8bit_storage : require
#extension GL_EXT_shader_16bit_storage : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;
layout(triangles, max_vertices = 64, max_primitives = 124) out;

struct Meshlet {
    float center[3];
    float radius;
    int8_t cone_axis[3];
    int8_t cone_cutoff;
    uint vertex_offset;
    uint triangle_offset;
    uint8_t vertex_count;
    uint8_t triangle_count;
    uint8_t padding[2];
};

struct Vertex {
    float pos[3];
    float color[3];
    float texCoord[2];
    float normal[3];
};

layout(buffer_reference, scalar) buffer Meshlets { Meshlet meshlets[]; };
layout(buffer_reference, scalar) buffer MeshletVertices { uint vertices[]; };
layout(buffer_reference, scalar) buffer MeshletTriangles { uint8_t indices[]; };
layout(buffer_reference, scalar) buffer Vertices { Vertex vertices[]; };

layout(push_constant) uniform PushConstants {
    mat4 model;
    mat4 normalMatrix;
    Meshlets meshletBuffer;
    MeshletVertices meshletVertices;
    MeshletTriangles meshletTriangles;
    Vertices vertexBuffer;
    uint meshletCount;
    uint instanceID;
} push;

layout(set = 0, binding = 0) uniform UniformBufferObject {
    mat4 view;
    mat4 proj;
    vec4 lightPos;
    vec4 viewPos;
    vec4 lightColor;
    mat4 lightSpaceMatrix;
    mat4 cascadeViewProj[4];
    vec4 cascadeSplits;
    vec4 shadowParams;
} ubo;

struct TaskPayload {
    uint meshletIndices[32];
};

taskPayloadSharedEXT TaskPayload payload;

// Output for visibility buffer
layout(location = 0) out flat uint meshletID[];
layout(location = 2) out flat uint instanceID[];

void main() {
    uint threadId = gl_LocalInvocationID.x;
    uint meshletIndex = payload.meshletIndices[gl_WorkGroupID.x];

    Meshlet m = push.meshletBuffer.meshlets[meshletIndex];

    uint vertexCount = uint(m.vertex_count);
    uint triangleCount = uint(m.triangle_count);

    SetMeshOutputsEXT(vertexCount, triangleCount);

    // Process vertices
    for (uint i = threadId; i < vertexCount; i += 32) {
        uint vertexIndex = m.vertex_offset + i;
        uint globalVertexIndex = push.meshletVertices.vertices[vertexIndex];
        
        Vertex v = push.vertexBuffer.vertices[globalVertexIndex];
        
        vec4 worldPos = push.model * vec4(v.pos[0], v.pos[1], v.pos[2], 1.0);
        gl_MeshVerticesEXT[i].gl_Position = ubo.proj * ubo.view * worldPos;
        
        meshletID[i] = meshletIndex;
        instanceID[i] = push.instanceID;
    }

    // Process triangles
    for (uint i = threadId; i < triangleCount; i += 32) {
        uint triangleIndex = m.triangle_offset + i * 3;
        
        uint8_t idx0 = push.meshletTriangles.indices[triangleIndex + 0];
        uint8_t idx1 = push.meshletTriangles.indices[triangleIndex + 1];
        uint8_t idx2 = push.meshletTriangles.indices[triangleIndex + 2];
        
        gl_PrimitiveTriangleIndicesEXT[i] = uvec3(idx0, idx1, idx2);
    }
}
