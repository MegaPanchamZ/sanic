/**
 * debug_overlay.comp
 * 
 * Debug visualization overlay shader.
 * Renders various debug views on top of the final image.
 * 
 * Turn 42: Debug visualization
 */

#version 460
#extension GL_EXT_scalar_block_layout : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// Input image
layout(set = 0, binding = 0, rgba8) readonly uniform image2D inputImage;

// Debug textures
layout(set = 0, binding = 1) uniform sampler2D depthBuffer;
layout(set = 0, binding = 2) uniform usampler2D visBuffer;
layout(set = 0, binding = 3) uniform sampler2D normalBuffer;
layout(set = 0, binding = 4) uniform sampler2D giBuffer;
layout(set = 0, binding = 5) uniform sampler2D shadowBuffer;

// Output
layout(set = 0, binding = 6, rgba8) writeonly uniform image2D outputImage;

// Push constants
layout(push_constant) uniform DebugParams {
    vec4 screenSize;    // xy = size, zw = 1/size
    uint debugMode;     // 0=none, 1=depth, 2=normals, 3=meshlets, 4=LOD, 5=GI, 6=shadows, 7=overdraw
    uint flags;
    float time;
    float pad;
} params;

// Debug mode flags
const uint DEBUG_NONE = 0;
const uint DEBUG_DEPTH = 1;
const uint DEBUG_NORMALS = 2;
const uint DEBUG_MESHLETS = 3;
const uint DEBUG_LOD = 4;
const uint DEBUG_GI = 5;
const uint DEBUG_SHADOWS = 6;
const uint DEBUG_OVERDRAW = 7;
const uint DEBUG_CLUSTERS = 8;
const uint DEBUG_MOTION = 9;

// Color palette for meshlet/cluster visualization
vec3 indexToColor(uint index) {
    // Use prime multipliers for nice color distribution
    float r = fract(float(index) * 0.618033988749895);
    float g = fract(float(index) * 0.381966011250105);
    float b = fract(float(index) * 0.756987051965472);
    return vec3(r, g, b);
}

// Heat map for scalar values (blue -> green -> yellow -> red)
vec3 heatMap(float t) {
    t = clamp(t, 0.0, 1.0);
    
    if (t < 0.25) {
        return mix(vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 1.0), t * 4.0);
    } else if (t < 0.5) {
        return mix(vec3(0.0, 1.0, 1.0), vec3(0.0, 1.0, 0.0), (t - 0.25) * 4.0);
    } else if (t < 0.75) {
        return mix(vec3(0.0, 1.0, 0.0), vec3(1.0, 1.0, 0.0), (t - 0.5) * 4.0);
    } else {
        return mix(vec3(1.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), (t - 0.75) * 4.0);
    }
}

// Turbo colormap (better perceptual uniformity)
vec3 turboColormap(float t) {
    const vec4 kRed = vec4(0.13572138, 4.61539260, -42.66032258, 132.13108234);
    const vec4 kGreen = vec4(0.09140261, 2.19418839, 4.84296658, -14.18503333);
    const vec4 kBlue = vec4(0.10667330, 12.64194608, -60.58204836, 110.36276771);
    const vec2 kMagic = vec2(2.75573192, -1.09890932);
    
    t = clamp(t, 0.0, 1.0);
    vec4 v = vec4(1.0, t, t * t, t * t * t);
    
    return vec3(
        dot(v, kRed) + kMagic.x * v.w * t,
        dot(v, kGreen) + kMagic.y * v.w * t,
        dot(v, kBlue)
    );
}

// Linearize depth
float linearizeDepth(float depth, float near, float far) {
    return (2.0 * near * far) / (far + near - depth * (far - near));
}

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    vec2 screenSize = params.screenSize.xy;
    
    if (pixelCoord.x >= int(screenSize.x) || pixelCoord.y >= int(screenSize.y)) {
        return;
    }
    
    vec2 uv = (vec2(pixelCoord) + 0.5) / screenSize;
    
    // Load original image
    vec4 originalColor = imageLoad(inputImage, pixelCoord);
    vec3 debugColor = originalColor.rgb;
    
    if (params.debugMode == DEBUG_NONE) {
        // No debug visualization
        imageStore(outputImage, pixelCoord, originalColor);
        return;
    }
    
    switch (params.debugMode) {
        case DEBUG_DEPTH: {
            float depth = texture(depthBuffer, uv).r;
            float near = 0.1;
            float far = 1000.0;
            float linearDepth = linearizeDepth(depth, near, far);
            float normalizedDepth = clamp(linearDepth / far, 0.0, 1.0);
            debugColor = turboColormap(normalizedDepth);
            break;
        }
        
        case DEBUG_NORMALS: {
            vec3 normal = texture(normalBuffer, uv).rgb;
            debugColor = normal * 0.5 + 0.5;
            break;
        }
        
        case DEBUG_MESHLETS: {
            uvec2 visData = texture(visBuffer, uv).rg;
            uint meshletId = visData.x;
            if (meshletId > 0) {
                debugColor = indexToColor(meshletId);
            } else {
                debugColor = vec3(0.0);
            }
            break;
        }
        
        case DEBUG_LOD: {
            // LOD visualization - extract LOD from visibility buffer
            uvec2 visData = texture(visBuffer, uv).rg;
            uint lodLevel = (visData.y >> 24) & 0xFF;
            debugColor = heatMap(float(lodLevel) / 8.0);
            break;
        }
        
        case DEBUG_GI: {
            // Show GI contribution only
            debugColor = texture(giBuffer, uv).rgb;
            break;
        }
        
        case DEBUG_SHADOWS: {
            // Show shadow mask
            float shadow = texture(shadowBuffer, uv).r;
            debugColor = vec3(shadow);
            break;
        }
        
        case DEBUG_OVERDRAW: {
            // Overdraw visualization (higher values = more overdraw)
            uvec2 visData = texture(visBuffer, uv).rg;
            uint overdrawCount = (visData.y >> 16) & 0xFF;
            debugColor = heatMap(float(overdrawCount) / 10.0);
            break;
        }
        
        case DEBUG_CLUSTERS: {
            // Cluster visualization
            uvec2 visData = texture(visBuffer, uv).rg;
            uint clusterId = visData.x >> 16;
            if (clusterId > 0) {
                debugColor = indexToColor(clusterId);
            } else {
                debugColor = vec3(0.0);
            }
            break;
        }
        
        default:
            break;
    }
    
    // Optional: blend with original
    float blendFactor = 1.0;
    if ((params.flags & 0x1) != 0) {
        blendFactor = 0.5;
    }
    
    vec3 finalColor = mix(originalColor.rgb, debugColor, blendFactor);
    imageStore(outputImage, pixelCoord, vec4(finalColor, 1.0));
}
