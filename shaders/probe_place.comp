/**
 * probe_place.comp
 * 
 * Places screen probes based on depth/normal discontinuities.
 * Adaptive placement for better coverage of complex geometry.
 * 
 * Turn 25-27: Screen probe placement
 */

#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : enable
#extension GL_EXT_buffer_reference : enable

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// Probe data structure
struct ScreenProbe {
    vec4 positionDepth;     // xyz = world pos, w = depth
    vec4 normalRadius;      // xyz = normal, w = radius
    ivec4 atlasInfo;        // x = atlasOffset, y = resolution, z = flags, w = tileIndex
};

layout(set = 0, binding = 0) uniform sampler2D depthBuffer;
layout(set = 0, binding = 1) uniform sampler2D normalBuffer;

layout(std430, set = 0, binding = 2) buffer ProbeBuffer {
    ScreenProbe probes[];
};

layout(std430, set = 0, binding = 3) buffer TileBuffer {
    uvec4 tiles[];  // x = probeIndex, y = probeCount, zw = avgDirection
};

layout(std430, set = 0, binding = 4) buffer CounterBuffer {
    uint probeCount;
    uint tileCount;
    uint maxProbes;
    uint padding;
};

layout(push_constant) uniform PushConstants {
    mat4 invViewProj;
    vec4 screenSize;        // xy = size, zw = 1/size
    uint tileSize;
    uint frameIndex;
    uint maxProbesPerTile;
    float depthThreshold;
    float normalThreshold;
    float padding1;
    float padding2;
    float padding3;
};

// Reconstruct world position from depth
vec3 reconstructWorldPos(vec2 uv, float depth) {
    vec4 clipPos = vec4(uv * 2.0 - 1.0, depth, 1.0);
    vec4 worldPos = invViewProj * clipPos;
    return worldPos.xyz / worldPos.w;
}

// Check if tile needs multiple probes (depth/normal discontinuity)
bool needsAdaptiveProbes(ivec2 tileCoord) {
    vec2 tileCenter = (vec2(tileCoord) + 0.5) * float(tileSize) * screenSize.zw;
    
    float centerDepth = texture(depthBuffer, tileCenter).r;
    vec3 centerNormal = texture(normalBuffer, tileCenter).xyz * 2.0 - 1.0;
    
    // Sample corners of tile
    float maxDepthDiff = 0.0;
    float maxNormalDiff = 0.0;
    
    for (int y = 0; y <= 1; y++) {
        for (int x = 0; x <= 1; x++) {
            vec2 cornerUV = (vec2(tileCoord) + vec2(x, y)) * float(tileSize) * screenSize.zw;
            
            float cornerDepth = texture(depthBuffer, cornerUV).r;
            vec3 cornerNormal = texture(normalBuffer, cornerUV).xyz * 2.0 - 1.0;
            
            maxDepthDiff = max(maxDepthDiff, abs(cornerDepth - centerDepth));
            maxNormalDiff = max(maxNormalDiff, 1.0 - dot(cornerNormal, centerNormal));
        }
    }
    
    return maxDepthDiff > depthThreshold || maxNormalDiff > normalThreshold;
}

// Generate probe at UV position
void generateProbe(vec2 uv, ivec2 tileCoord, uint localIndex) {
    float depth = texture(depthBuffer, uv).r;
    
    // Skip sky pixels
    if (depth >= 1.0) return;
    
    vec3 normal = texture(normalBuffer, uv).xyz * 2.0 - 1.0;
    vec3 worldPos = reconstructWorldPos(uv, depth);
    
    // Allocate probe
    uint probeIndex = atomicAdd(probeCount, 1);
    if (probeIndex >= maxProbes) {
        atomicAdd(probeCount, -1);
        return;
    }
    
    // Calculate probe radius based on tile size and depth
    float linearDepth = 1.0 / (depth * 0.5 + 0.5);
    float radius = linearDepth * float(tileSize) * 0.1;
    
    // Calculate atlas offset
    uint atlasOffset = probeIndex * 64; // 8x8 per probe
    
    // Store probe
    probes[probeIndex].positionDepth = vec4(worldPos, depth);
    probes[probeIndex].normalRadius = vec4(normal, radius);
    probes[probeIndex].atlasInfo = ivec4(
        int(atlasOffset),
        8,  // resolution
        1,  // valid flag
        int(tileCoord.y * 1024 + tileCoord.x)
    );
    
    // Update tile info
    uint tileIndex = tileCoord.y * uint(ceil(screenSize.x / float(tileSize))) + tileCoord.x;
    if (localIndex == 0) {
        tiles[tileIndex].x = probeIndex;
    }
    atomicAdd(tiles[tileIndex].y, 1);
}

void main() {
    ivec2 tileCoord = ivec2(gl_WorkGroupID.xy);
    ivec2 localCoord = ivec2(gl_LocalInvocationID.xy);
    
    uint tilesX = uint(ceil(screenSize.x / float(tileSize)));
    uint tilesY = uint(ceil(screenSize.y / float(tileSize)));
    
    if (tileCoord.x >= tilesX || tileCoord.y >= tilesY) return;
    
    // Initialize tile
    uint tileIndex = tileCoord.y * tilesX + tileCoord.x;
    if (localCoord.x == 0 && localCoord.y == 0) {
        tiles[tileIndex] = uvec4(0);
    }
    
    barrier();
    
    // Check if we need adaptive placement
    bool adaptive = needsAdaptiveProbes(tileCoord);
    
    if (adaptive) {
        // Place multiple probes at 2x2 grid within tile
        if (localCoord.x < 2 && localCoord.y < 2) {
            vec2 subTileOffset = (vec2(localCoord) + 0.5) * 0.5;
            vec2 uv = (vec2(tileCoord) + subTileOffset) * float(tileSize) * screenSize.zw;
            
            uint localIndex = localCoord.y * 2 + localCoord.x;
            if (localIndex < maxProbesPerTile) {
                generateProbe(uv, tileCoord, localIndex);
            }
        }
    } else {
        // Single probe at tile center
        if (localCoord.x == 0 && localCoord.y == 0) {
            vec2 uv = (vec2(tileCoord) + 0.5) * float(tileSize) * screenSize.zw;
            generateProbe(uv, tileCoord, 0);
        }
    }
}
