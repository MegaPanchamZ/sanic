/**
 * bloom_upsample.comp
 * 
 * Upsample pass for bloom combining.
 * Uses tent filter with additive blending.
 * 
 * Turn 37-39: Post-processing
 */

#version 460

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform sampler2D smallerMip;   // Upsampled from
layout(set = 0, binding = 1) uniform sampler2D largerMip;    // Current resolution
layout(set = 0, binding = 2, rgba16f) writeonly uniform image2D outputImage;

layout(push_constant) uniform PushConstants {
    vec2 smallerSize;
    vec2 largerSize;
    float bloomIntensity;
    float bloomRadius;
    uint mipLevel;
    uint isFinalPass;
} pc;

// 9-tap tent filter for smooth upsampling
vec3 upsample9Tap(vec2 uv, vec2 texelSize, float radius) {
    vec4 offset = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0) * radius;
    
    vec3 s;
    s  = texture(smallerMip, uv + offset.xy).rgb;
    s += texture(smallerMip, uv + offset.zy).rgb;
    s += texture(smallerMip, uv + offset.xw).rgb;
    s += texture(smallerMip, uv + offset.zw).rgb;
    
    s += texture(smallerMip, uv + vec2(offset.x, 0.0)).rgb * 2.0;
    s += texture(smallerMip, uv + vec2(offset.z, 0.0)).rgb * 2.0;
    s += texture(smallerMip, uv + vec2(0.0, offset.y)).rgb * 2.0;
    s += texture(smallerMip, uv + vec2(0.0, offset.w)).rgb * 2.0;
    
    s += texture(smallerMip, uv).rgb * 4.0;
    
    return s / 16.0;
}

void main() {
    uvec2 gid = gl_GlobalInvocationID.xy;
    if (gid.x >= uint(pc.largerSize.x) || gid.y >= uint(pc.largerSize.y)) return;
    
    vec2 uv = (vec2(gid) + 0.5) / pc.largerSize;
    vec2 texelSize = 1.0 / pc.smallerSize;
    
    // Upsample smaller mip
    vec3 upsampled = upsample9Tap(uv, texelSize, pc.bloomRadius);
    
    // Add to larger mip (or output if final pass)
    vec3 larger = texture(largerMip, uv).rgb;
    
    vec3 result = larger + upsampled * pc.bloomIntensity;
    
    imageStore(outputImage, ivec2(gid), vec4(result, 1.0));
}
