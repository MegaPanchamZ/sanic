/**
 * motion_blur.comp
 * 
 * Per-object motion blur using velocity buffer.
 * 
 * Turn 37-39: Post-processing
 */

#version 460

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform sampler2D colorBuffer;
layout(set = 0, binding = 1) uniform sampler2D velocityBuffer;  // Screen-space velocity
layout(set = 0, binding = 2) uniform sampler2D depthBuffer;
layout(set = 0, binding = 3, rgba16f) writeonly uniform image2D outputImage;

layout(push_constant) uniform PushConstants {
    float velocityScale;      // Motion blur strength
    float maxVelocity;        // Max blur length in pixels
    uint sampleCount;
    float centerWeight;       // Weight for center sample
    float softZCompare;       // Depth comparison softness
    uint width;
    uint height;
    uint pad;
} pc;

// Interleaved gradient noise for jitter
float interleavedGradientNoise(uvec2 coord) {
    vec2 f = vec2(coord);
    return fract(52.9829189 * fract(0.06711056 * f.x + 0.00583715 * f.y));
}

// Soft depth compare
float softDepthCompare(float za, float zb) {
    return clamp(1.0 - (za - zb) * pc.softZCompare, 0.0, 1.0);
}

// Cone weight for sample falloff
float cone(float dist, float velocityLen) {
    return clamp(1.0 - dist / velocityLen, 0.0, 1.0);
}

// Cylinder weight
float cylinder(float dist, float velocityLen) {
    return 1.0 - smoothstep(0.95 * velocityLen, 1.05 * velocityLen, dist);
}

void main() {
    uvec2 gid = gl_GlobalInvocationID.xy;
    if (gid.x >= pc.width || gid.y >= pc.height) return;
    
    vec2 uv = (vec2(gid) + 0.5) / vec2(pc.width, pc.height);
    vec2 texelSize = 1.0 / vec2(pc.width, pc.height);
    
    // Sample velocity (in NDC per frame)
    vec2 velocity = texture(velocityBuffer, uv).xy * pc.velocityScale;
    
    // Clamp velocity to max blur
    float velocityLen = length(velocity * vec2(pc.width, pc.height));
    if (velocityLen > pc.maxVelocity) {
        velocity = velocity * (pc.maxVelocity / velocityLen);
        velocityLen = pc.maxVelocity;
    }
    
    // Early out if no motion
    if (velocityLen < 0.5) {
        vec4 color = texture(colorBuffer, uv);
        imageStore(outputImage, ivec2(gid), color);
        return;
    }
    
    // Center sample
    vec4 centerColor = texture(colorBuffer, uv);
    float centerDepth = texture(depthBuffer, uv).r;
    
    // Jitter start position
    float jitter = interleavedGradientNoise(gid) - 0.5;
    
    // Accumulate samples along velocity
    vec4 color = centerColor * pc.centerWeight;
    float totalWeight = pc.centerWeight;
    
    for (uint i = 0; i < pc.sampleCount; i++) {
        float t = (float(i) + jitter) / float(pc.sampleCount) - 0.5;
        vec2 sampleOffset = velocity * t;
        vec2 sampleUV = uv + sampleOffset;
        
        // Skip out-of-bounds
        if (any(lessThan(sampleUV, vec2(0.0))) || any(greaterThan(sampleUV, vec2(1.0)))) {
            continue;
        }
        
        vec4 sampleColor = texture(colorBuffer, sampleUV);
        float sampleDepth = texture(depthBuffer, sampleUV).r;
        vec2 sampleVelocity = texture(velocityBuffer, sampleUV).xy * pc.velocityScale;
        
        float sampleDist = abs(t) * velocityLen;
        float sampleVelLen = length(sampleVelocity * vec2(pc.width, pc.height));
        
        // Depth comparison
        float foreground = softDepthCompare(centerDepth, sampleDepth);
        float background = softDepthCompare(sampleDepth, centerDepth);
        
        // Weight based on overlap
        float weight = 0.0;
        
        // Case 1: Sample moving enough to blur over center
        weight += foreground * cone(sampleDist, sampleVelLen);
        
        // Case 2: Center moving over background sample
        weight += background * cone(sampleDist, velocityLen);
        
        // Case 3: Both moving (cylinder kernel)
        weight += cylinder(sampleDist, velocityLen) * cylinder(sampleDist, sampleVelLen);
        
        color += sampleColor * weight;
        totalWeight += weight;
    }
    
    color /= totalWeight;
    
    imageStore(outputImage, ivec2(gid), color);
}
