/**
 * card_capture.comp
 * 
 * Captures direct lighting onto mesh cards for surface cache.
 * Each card represents one face of a mesh's bounding box.
 * 
 * Turn 16-18: Surface cache card capture
 */

#version 460
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// Card data structure
struct MeshCard {
    vec4 centerExtent;      // xyz = center, w = extent
    vec4 normalAtlas;       // xyz = normal, w = packed atlas offset
    vec4 atlasSizeMeshId;   // xy = size, z = meshId, w = cardIndex
    vec4 boundsMin;
    vec4 boundsMax;
};

// Light data
struct Light {
    vec4 positionType;      // xyz = position, w = type (0=point, 1=dir, 2=spot)
    vec4 directionRange;    // xyz = direction, w = range
    vec4 colorIntensity;    // xyz = color, w = intensity
    vec4 spotParams;        // x = inner angle, y = outer angle, z,w = unused
};

// Buffer references
layout(buffer_reference, std430, buffer_reference_align = 16) readonly buffer CardBuffer {
    MeshCard cards[];
};

layout(buffer_reference, std430, buffer_reference_align = 16) readonly buffer LightBuffer {
    uint lightCount;
    uint pad0, pad1, pad2;
    Light lights[];
};

layout(buffer_reference, std430, buffer_reference_align = 4) readonly buffer VertexBuffer {
    float vertices[];
};

layout(buffer_reference, std430, buffer_reference_align = 4) readonly buffer IndexBuffer {
    uint indices[];
};

// Output atlas
layout(set = 0, binding = 0, rgba16f) writeonly uniform image2D radianceAtlas;
layout(set = 0, binding = 1, rgba16f) writeonly uniform image2D normalAtlas;
layout(set = 0, binding = 2, r32f) writeonly uniform image2D depthAtlas;

// Shadow map
layout(set = 0, binding = 3) uniform sampler2DShadow shadowMap;

// Push constants
layout(push_constant) uniform PushConstants {
    mat4 lightViewProj;
    
    uint64_t cardAddr;
    uint64_t lightAddr;
    uint64_t vertexAddr;
    uint64_t indexAddr;
    
    uint cardIndex;         // Which card to capture
    uint cardResolution;    // Resolution of this card
    uint atlasOffsetX;
    uint atlasOffsetY;
    
    vec3 ambientLight;
    float shadowBias;
};

// Compute world position from card UV
vec3 cardUVToWorld(vec2 uv, MeshCard card) {
    vec3 center = card.centerExtent.xyz;
    float extent = card.centerExtent.w;
    vec3 normal = card.normalAtlas.xyz;
    
    // Create tangent frame from normal
    vec3 up = abs(normal.y) < 0.999 ? vec3(0, 1, 0) : vec3(1, 0, 0);
    vec3 tangent = normalize(cross(up, normal));
    vec3 bitangent = cross(normal, tangent);
    
    // Map UV from [0,1] to [-1,1]
    vec2 localPos = (uv * 2.0 - 1.0) * extent;
    
    // Compute world position on card surface
    return center + tangent * localPos.x + bitangent * localPos.y;
}

// Sample shadow map
float sampleShadow(vec3 worldPos, mat4 lightVP) {
    vec4 lightSpace = lightVP * vec4(worldPos, 1.0);
    lightSpace.xyz /= lightSpace.w;
    
    // Transform to shadow map UV
    vec2 shadowUV = lightSpace.xy * 0.5 + 0.5;
    float currentDepth = lightSpace.z;
    
    // Check bounds
    if (shadowUV.x < 0.0 || shadowUV.x > 1.0 || 
        shadowUV.y < 0.0 || shadowUV.y > 1.0 ||
        currentDepth < 0.0 || currentDepth > 1.0) {
        return 1.0;  // Outside shadow map = lit
    }
    
    // PCF shadow sampling
    float shadow = 0.0;
    vec2 texelSize = 1.0 / vec2(textureSize(shadowMap, 0));
    
    for (int x = -1; x <= 1; x++) {
        for (int y = -1; y <= 1; y++) {
            vec2 offset = vec2(x, y) * texelSize;
            shadow += texture(shadowMap, vec3(shadowUV + offset, currentDepth - shadowBias));
        }
    }
    
    return shadow / 9.0;
}

// Evaluate lighting at a point
vec3 evaluateLighting(vec3 worldPos, vec3 normal, LightBuffer lights) {
    vec3 totalLight = ambientLight;
    
    for (uint i = 0; i < lights.lightCount; i++) {
        Light light = lights.lights[i];
        
        vec3 lightColor = light.colorIntensity.xyz * light.colorIntensity.w;
        float lightType = light.positionType.w;
        
        vec3 L;
        float attenuation = 1.0;
        
        if (lightType < 0.5) {
            // Point light
            vec3 toLight = light.positionType.xyz - worldPos;
            float dist = length(toLight);
            L = toLight / dist;
            
            float range = light.directionRange.w;
            attenuation = max(0.0, 1.0 - (dist / range));
            attenuation *= attenuation;
        } else if (lightType < 1.5) {
            // Directional light
            L = -light.directionRange.xyz;
        } else {
            // Spot light
            vec3 toLight = light.positionType.xyz - worldPos;
            float dist = length(toLight);
            L = toLight / dist;
            
            float range = light.directionRange.w;
            attenuation = max(0.0, 1.0 - (dist / range));
            attenuation *= attenuation;
            
            // Spot cone
            float cosAngle = dot(-L, light.directionRange.xyz);
            float innerCos = cos(light.spotParams.x);
            float outerCos = cos(light.spotParams.y);
            attenuation *= smoothstep(outerCos, innerCos, cosAngle);
        }
        
        float NdotL = max(0.0, dot(normal, L));
        
        // Shadow
        float shadow = sampleShadow(worldPos, lightViewProj);
        
        totalLight += lightColor * NdotL * attenuation * shadow;
    }
    
    return totalLight;
}

void main() {
    uvec2 localCoord = gl_GlobalInvocationID.xy;
    
    if (localCoord.x >= cardResolution || localCoord.y >= cardResolution) {
        return;
    }
    
    // Compute UV within card
    vec2 uv = (vec2(localCoord) + 0.5) / float(cardResolution);
    
    // Get card data
    CardBuffer cardBuf = CardBuffer(cardAddr);
    MeshCard card = cardBuf.cards[cardIndex];
    
    // Compute world position
    vec3 worldPos = cardUVToWorld(uv, card);
    vec3 normal = card.normalAtlas.xyz;
    
    // Get light buffer
    LightBuffer lights = LightBuffer(lightAddr);
    
    // Evaluate lighting
    vec3 radiance = evaluateLighting(worldPos, normal, lights);
    
    // Compute depth from card center (for parallax)
    float depth = 0.0;  // Cards are flat, depth = 0 at surface
    
    // Write to atlas
    ivec2 atlasCoord = ivec2(atlasOffsetX + localCoord.x, atlasOffsetY + localCoord.y);
    
    imageStore(radianceAtlas, atlasCoord, vec4(radiance, 1.0));
    imageStore(normalAtlas, atlasCoord, vec4(normal * 0.5 + 0.5, 1.0));
    imageStore(depthAtlas, atlasCoord, vec4(depth));
}
