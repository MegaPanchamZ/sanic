#version 460
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_shader_atomic_int64 : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_shader_8bit_storage : require
#extension GL_EXT_shader_image_int64 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

struct Meshlet {
    float center[3];
    float radius;
    int8_t cone_axis[3];
    int8_t cone_cutoff;
    uint vertex_offset;
    uint triangle_offset;
    uint8_t vertex_count;
    uint8_t triangle_count;
    uint8_t padding[2];
};

struct Vertex {
    float pos[3];
    float color[3];
    float texCoord[2];
    float normal[3];
};

layout(buffer_reference, scalar) buffer Meshlets { Meshlet meshlets[]; };
layout(buffer_reference, scalar) buffer MeshletVertices { uint vertices[]; };
layout(buffer_reference, scalar) buffer MeshletTriangles { uint8_t indices[]; };
layout(buffer_reference, scalar) buffer Vertices { Vertex vertices[]; };

layout(push_constant) uniform PushConstants {
    mat4 model;
    mat4 normalMatrix;
    Meshlets meshletBuffer;
    MeshletVertices meshletVertices;
    MeshletTriangles meshletTriangles;
    Vertices vertexBuffer;
    uint meshletCount;
    uint instanceID;
    vec2 screenSize;
} push;

layout(set = 0, binding = 0) uniform UniformBufferObject {
    mat4 view;
    mat4 proj;
    // ...
} ubo;

// R64_UINT Visibility Buffer
layout(set = 0, binding = 1, r64ui) uniform u64image2D visBuffer;

// Helper to project vertex
vec4 project(vec3 pos) {
    return ubo.proj * ubo.view * push.model * vec4(pos, 1.0);
}

void main() {
    uint meshletIndex = gl_WorkGroupID.x;
    uint threadId = gl_LocalInvocationID.x;
    
    if (meshletIndex >= push.meshletCount) return;
    
    Meshlet m = push.meshletBuffer.meshlets[meshletIndex];
    uint triangleCount = uint(m.triangle_count);
    
    // Each thread processes triangles? Or one meshlet per workgroup?
    // Let's say one meshlet per workgroup, threads process triangles.
    
    for (uint i = threadId; i < triangleCount; i += 32) {
        uint triangleIndex = m.triangle_offset + i * 3;
        
        uint8_t idx0 = push.meshletTriangles.indices[triangleIndex + 0];
        uint8_t idx1 = push.meshletTriangles.indices[triangleIndex + 1];
        uint8_t idx2 = push.meshletTriangles.indices[triangleIndex + 2];
        
        uint vIdx0 = push.meshletVertices.vertices[m.vertex_offset + uint(idx0)];
        uint vIdx1 = push.meshletVertices.vertices[m.vertex_offset + uint(idx1)];
        uint vIdx2 = push.meshletVertices.vertices[m.vertex_offset + uint(idx2)];
        
        Vertex v0 = push.vertexBuffer.vertices[vIdx0];
        Vertex v1 = push.vertexBuffer.vertices[vIdx1];
        Vertex v2 = push.vertexBuffer.vertices[vIdx2];
        
        vec4 p0 = project(vec3(v0.pos[0], v0.pos[1], v0.pos[2]));
        vec4 p1 = project(vec3(v1.pos[0], v1.pos[1], v1.pos[2]));
        vec4 p2 = project(vec3(v2.pos[0], v2.pos[1], v2.pos[2]));
        
        // Simple Rasterization Logic (Barycentric)
        // ... (Omitting full barycentric rasterizer for brevity, implementing bounding box fill)
        
        // Perspective divide
        vec3 ndc0 = p0.xyz / p0.w;
        vec3 ndc1 = p1.xyz / p1.w;
        vec3 ndc2 = p2.xyz / p2.w;
        
        // Screen coords
        vec2 scr0 = (ndc0.xy * 0.5 + 0.5) * push.screenSize;
        vec2 scr1 = (ndc1.xy * 0.5 + 0.5) * push.screenSize;
        vec2 scr2 = (ndc2.xy * 0.5 + 0.5) * push.screenSize;
        
        // Bounding Box
        vec2 minPos = min(scr0, min(scr1, scr2));
        vec2 maxPos = max(scr0, max(scr1, scr2));
        
        // Clamp to screen
        minPos = max(minPos, vec2(0, 0));
        maxPos = min(maxPos, push.screenSize - 1.0);
        
        // Iterate pixels in BB (Very inefficient for large triangles, but this is for SMALL triangles)
        for (int y = int(minPos.y); y <= int(maxPos.y); y++) {
            for (int x = int(minPos.x); x <= int(maxPos.x); x++) {
                // Barycentric check would go here
                
                // Calculate Depth (Interpolated)
                float z = (ndc0.z + ndc1.z + ndc2.z) / 3.0; // Approximation
                
                uint64_t depth = uint64_t(z * 32767.0) & 0x7FFF;
                uint64_t instanceID = uint64_t(push.instanceID) & 0xFFFFF;
                uint64_t clusterID = uint64_t(meshletIndex) & 0x3FFFFF;
                uint64_t triID = uint64_t(i) & 0x7F;
                
                uint64_t payload = (depth << 49) | (instanceID << 29) | (clusterID << 7) | triID;
                
                imageAtomicMin(visBuffer, ivec2(x, y), payload);
            }
        }
    }
}
