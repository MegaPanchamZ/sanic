/**
 * bloom_downsample.comp
 * 
 * Downsample pass for bloom extraction.
 * Uses 13-tap tent filter for quality downsampling.
 * 
 * Turn 37-39: Post-processing
 */

#version 460

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform sampler2D inputImage;
layout(set = 0, binding = 1, rgba16f) writeonly uniform image2D outputImage;

layout(push_constant) uniform PushConstants {
    vec2 inputSize;
    vec2 outputSize;
    float threshold;      // Bloom threshold for first pass
    float softThreshold;  // Soft knee threshold
    uint mipLevel;
    uint isFirstPass;
} pc;

// Soft threshold function
vec3 softThreshold(vec3 color) {
    float brightness = max(max(color.r, color.g), color.b);
    
    float soft = brightness - pc.threshold + pc.softThreshold;
    soft = clamp(soft, 0.0, 2.0 * pc.softThreshold);
    soft = soft * soft / (4.0 * pc.softThreshold + 0.0001);
    
    float contribution = max(soft, brightness - pc.threshold);
    contribution /= max(brightness, 0.0001);
    
    return color * max(contribution, 0.0);
}

// 13-tap tent filter (Karis average for first pass)
vec3 downsample13Tap(vec2 uv, vec2 texelSize) {
    vec3 a = texture(inputImage, uv + texelSize * vec2(-1.0, -1.0)).rgb;
    vec3 b = texture(inputImage, uv + texelSize * vec2( 0.0, -1.0)).rgb;
    vec3 c = texture(inputImage, uv + texelSize * vec2( 1.0, -1.0)).rgb;
    vec3 d = texture(inputImage, uv + texelSize * vec2(-0.5, -0.5)).rgb;
    vec3 e = texture(inputImage, uv + texelSize * vec2( 0.5, -0.5)).rgb;
    vec3 f = texture(inputImage, uv + texelSize * vec2(-1.0,  0.0)).rgb;
    vec3 g = texture(inputImage, uv).rgb;
    vec3 h = texture(inputImage, uv + texelSize * vec2( 1.0,  0.0)).rgb;
    vec3 i = texture(inputImage, uv + texelSize * vec2(-0.5,  0.5)).rgb;
    vec3 j = texture(inputImage, uv + texelSize * vec2( 0.5,  0.5)).rgb;
    vec3 k = texture(inputImage, uv + texelSize * vec2(-1.0,  1.0)).rgb;
    vec3 l = texture(inputImage, uv + texelSize * vec2( 0.0,  1.0)).rgb;
    vec3 m = texture(inputImage, uv + texelSize * vec2( 1.0,  1.0)).rgb;
    
    vec3 result;
    
    if (pc.isFirstPass > 0) {
        // Use Karis average to prevent fireflies
        vec3 groups[5];
        groups[0] = (a + b + f + g) * 0.25;
        groups[1] = (b + c + g + h) * 0.25;
        groups[2] = (f + g + k + l) * 0.25;
        groups[3] = (g + h + l + m) * 0.25;
        groups[4] = (d + e + i + j) * 0.25;
        
        float kw[5];
        for (int n = 0; n < 5; n++) {
            float luma = dot(groups[n], vec3(0.2126, 0.7152, 0.0722));
            kw[n] = 1.0 / (1.0 + luma);
        }
        
        float totalWeight = kw[0] + kw[1] + kw[2] + kw[3] + kw[4] * 4.0;
        result = (groups[0] * kw[0] + groups[1] * kw[1] + groups[2] * kw[2] + 
                  groups[3] * kw[3] + groups[4] * kw[4] * 4.0) / totalWeight;
    } else {
        // Standard 13-tap filter
        result = g * 0.125;
        result += (a + c + k + m) * 0.03125;
        result += (b + f + h + l) * 0.0625;
        result += (d + e + i + j) * 0.125;
    }
    
    return result;
}

void main() {
    uvec2 gid = gl_GlobalInvocationID.xy;
    if (gid.x >= uint(pc.outputSize.x) || gid.y >= uint(pc.outputSize.y)) return;
    
    vec2 uv = (vec2(gid) + 0.5) / pc.outputSize;
    vec2 texelSize = 1.0 / pc.inputSize;
    
    vec3 color = downsample13Tap(uv, texelSize);
    
    // Apply threshold on first pass
    if (pc.isFirstPass > 0) {
        color = softThreshold(color);
    }
    
    imageStore(outputImage, ivec2(gid), vec4(color, 1.0));
}
